# clear variables and close windows
rm(list=ls(all=TRUE))
graphics.off()
# open library
install.packages("fExtremes")
library(fExtremes)
# load data
PL = read.table("XFGPL3.dat")
MMPL = read.table("XFGMMPL3.dat")
# compute VaR for upper tail of the empirical distribution function with alpha = 0.01.
n = nrow(PL)
j = 1
VaRSu = NULL
while (j<=n){
Vinput = t(PL[j,])
temp = VaR(Vinput, alpha=0.01,type="sample", tail=c("upper"))
VaRSu[j] = temp
j=j+1
}
# compute VaR for lower tail of the empirical distribution function with alpha = 0.01.
j = 1
VaRSl = NULL
while (j<=n){
Vinput = t(PL[j,])
temp = VaR(Vinput, alpha=0.01,type="sample", tail=c("lower"))
VaRSl[j] = temp
j=j+1
}
# dummy for time variable
x = 1:nrow(MMPL)
# plot of the time series and its VaR estimates (red lines)
plot(x,t(MMPL),type="p",pch=19,cex=0.15, ylab=paste("Returns*",expression(E-3)), xlab=paste("Time*",expression(E2)), main="VaR Timeplot", axes=F, frame=T, ylim=c(-0.016,0.016))
axis(side=1, at=seq(0,1500,500),labels=seq(0,15,5))
axis(side=2, at=seq(-0.015,0.015,0.005),labels=seq(-15,15,5))
lines(VaRSl,col="red3", lwd=1.5)
lines(VaRSu,col="red3", lwd=1.5)
# QQ-Plot for lower tail
VaRqqplot = function(y,VaR0){
y = as.vector(MMPL)
bad=(nrow(y)>2)
if(bad==FALSE){ paste("y must be vector or matrix")}
#
n = nrow(y)
d = ncol(y)
#
h=0
w=matrix(1,1,d)
p=apply(y*w,1,sum) # portfolio
#;
p=p[(h+1):n]
qn=qnorm(((1:(n-h))-0.5)/(n-h),0,1) # compute quantiles of a standard normal
tmp=p/c(VaR0)
line=c(min(-4,min(qn),min(tmp)),max(4,max(qn),max(tmp)))
VaRqq=cbind(sort(qn),sort(tmp))
#
dev.new()
qqplot(VaRqq[,1],VaRqq[,2],ylim=c(-4,4),xlim=c(-4,4),pch=19,cex=0.3,col="red3",main="VaR reliability plot", ylab="L/VaR quantiles", xlab="normal quantiles")
lines(line,line,lwd=2)
}
VaRqqplot(MMPL,VaRSl)
# clear variables and close windows
rm(list=ls(all=TRUE))
graphics.off()
# open library
install.packages("fExtremes")
library(fExtremes)
# load data
PL = read.table("XFGPL3.dat")
MMPL = read.table("XFGMMPL3.dat")
install.packages("fExtremes")
n = nrow(PL)
j = 1
VaRSu = NULL
while (j<=n){
Vinput = t(PL[j,])
temp = VaR(Vinput, alpha=0.01,type="sample", tail=c("upper"))
VaRSu[j] = temp
j=j+1
}
n = nrow(PL)
j = 1
VaRSu = NULL
while (j<=n){
Vinput = t(PL[j,])
temp = VaR(Vinput, alpha=0.01,type="sample", tail=c("upper"))
VaRSu[j] = temp
j=j+1
}
# clear variables and close windows
rm(list = ls(all = TRUE))
graphics.off()
# set working directory to source file location and read the data
# setwd("C:/...")
x = read.table("Returns.txt", header = TRUE)
# define the function
sum.stat = function(X) {
# Computes the mean, standard deviation, median, quantiles (10% and 90 %),
# skewness and kurtosis of the input data. If the the input data is a
# matrix, the calculations are done on the columns.
#
# Args:
#   x: Input Data
m   = apply(x,2,mean)  # mean
sd  = apply(x, 2, sd)  # standard deviation
med = apply(x, 2, median)  # median
q   = apply(x, 2, quantile, probs = c(0.1, 0.9))  # quantiles
z    = scale(x)  # normalize columns of x
skew = colSums(z^3)/(dim(x)[1])  # skewness
kurt = colSums(z^4)/(dim(x)[1])  # kurtosis
tab            = data.frame(cbind(m, sd, med, t(q), skew, kurt))  # create table with results
names(tab)     = c("Mean", "SD", "Median", "0.1-q", "0.9-q", "Skewness",
"Kurtosis")  # name table columns
row.names(tab) = names(x)  # name table rows
return(tab)
}
# call function
sum.stat(x)
# clear variables and close windows
rm(list = ls(all = TRUE))
graphics.off()
# set working directory to source file location and read the data
# setwd("C:/...")
x = read.table("XFGSummary2 Returns.txt", header = TRUE)
# define the function
sum.stat = function(X) {
# Computes the mean, standard deviation, median, quantiles (10% and 90 %),
# skewness and kurtosis of the input data. If the the input data is a
# matrix, the calculations are done on the columns.
#
# Args:
#   x: Input Data
m   = apply(x,2,mean)  # mean
sd  = apply(x, 2, sd)  # standard deviation
med = apply(x, 2, median)  # median
q   = apply(x, 2, quantile, probs = c(0.1, 0.9))  # quantiles
z    = scale(x)  # normalize columns of x
skew = colSums(z^3)/(dim(x)[1])  # skewness
kurt = colSums(z^4)/(dim(x)[1])  # kurtosis
tab            = data.frame(cbind(m, sd, med, t(q), skew, kurt))  # create table with results
names(tab)     = c("Mean", "SD", "Median", "0.1-q", "0.9-q", "Skewness",
"Kurtosis")  # name table columns
row.names(tab) = names(x)  # name table rows
return(tab)
}
# call function
sum.stat(x)
rm(list = ls(all = TRUE))
graphics.off()
x = read.table("XFGSummary2 Returns.txt", header = TRUE)
x = read.table("XFGSummary2Returns.txt", header = TRUE)
x = read.table("XFGSummary2 Returns", header = TRUE)
# clear variables and close windows
rm(list = ls(all = TRUE))
graphics.off()
x = read.table("XFGSummary2 Returns", header = TRUE)
x = read.table("XFGSummary2Returns.", header = TRUE)
x = read.table("XFGSummary2Returns", header = TRUE)
x = read.table("XFGSummary2Returns.txt", header = TRUE)
