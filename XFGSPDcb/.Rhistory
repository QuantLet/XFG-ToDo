rm(list=ls(all=TRUE))
graphics.off()
library(matlab)
library(locpol)
library(KernSmooth)
SPDlp2 = function(RawData, xGrid, locband, metric){
rm(list=ls(all=TRUE))
graphics.off()
library(matlab)
library(locpol)
library(KernSmooth)
SPDlp2 = function(RawData, xGrid, locband, metric){
SPDlp2 = function(RawData, xGrid, locband, metric){
p            = 2
# error((sum(sum(RawData<0)')>=1),"Watch out: Some of your data entries are negative!!")
# error((cols(RawData)!=7),"data matrix must contain 7 columns")
# error((sum((RawData[,6]!=1)&&(RawData[,6]!=0))>=1),"type needs to be either 1 or zero")
# error(((metric!=0)&&(metric!=1)),"metric needs to be either 0 or 1")
Scorrected   = as.matrix(RawData[,1]*exp(-RawData[,3]*RawData[,4]))
Moneyness    = Scorrected/RawData[,2]
Maturity     = RawData[,4]
ivola        = RawData[,7]
################################################################################################
# The following case corresponds to:
# RawData entails data of one smile!
if (metric==0){
xGridTemp   = as.matrix(Scorrected[1]/xGrid)
}else{
if (metric==1){
xGridTemp = as.matrix(Scorrected[1]/(xGrid*RawData[1,1]))
}
}
hGrid         = c(seq(0.02,by=0.05,length=10),seq(0.5,by=0.2,length=15))
# In the next lines, we first estimate the smile with an automatic selection of the local bandwidths.
# Then, we reuse the same bandwiths to estimate the first and second derivative of the smile!
# In a last step, we use these estimations to compute the spd using the result of Rookley (see spdbl.xpl)
MoneynessSTD  = (Moneyness-matrix(mean(Moneyness),nrow(Moneyness),ncol(Moneyness)))/matrix(sqrt(var(Moneyness)),nrow(Moneyness),ncol(Moneyness))
xGridTempSTD  = (xGridTemp[,1]-mean(Moneyness))/sqrt(var(Moneyness))
dataf         = data.frame(tmp1=MoneynessSTD,tmp2=ivola)
smile         = locpoly(x=MoneynessSTD,y=ivola,gridsize=length(xGridTempSTD),range.x=c(min(xGridTempSTD),max(xGridTempSTD)),bandwidth=locband)$y
FirstDerSmile = locpoly(x=MoneynessSTD,y=ivola,gridsize=length(xGridTempSTD),range.x=c(min(xGridTempSTD),max(xGridTempSTD)),bandwidth=locband,drv=1)$y/c(sqrt(var(Moneyness)))
SecondDerSmile= locpoly(x=MoneynessSTD,y=ivola,gridsize=length(xGridTempSTD),range.x=c(min(xGridTempSTD),max(xGridTempSTD)),bandwidth=locband,drv=2)$y/c(var(Moneyness))
result        = spdbl(flipud(xGridTemp),smile,FirstDerSmile,SecondDerSmile,Scorrected[1,1],RawData[1,3],RawData[1,4])
if (metric==0){
fstar=result$fstar
}else{
fstar=RawData[1,1]*result$fstar
}
band=locband
return(list(fstar=fstar,band=band))
}
